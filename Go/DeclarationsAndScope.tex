% !TeX root = Main.tex
\chapter{声明和作用域}
一个声明将一个非空白标识符绑定到一个常量、类型、变量、函数、标签或者包。
程序中的每一个标识符必须被声明。
相同块中不可以将重复声明一个标识符，并且标识符不可同时声明在文件块和包块中。

空白标识符可以和声明中的任何其他标识符一样使用，但是不会引入一个绑定，因而不是一个声明。
在包块中，标识符 \lstinline|init| 可能会用作 init 函数声明，和空白标识符一样也不会引入一个新的绑定。
\begin{lstlisting}[style=EBNF]
Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
\end{lstlisting}
被声明的标识符的作用域是标识符表示特定常量，类型，变量，函数，标签，或包的源文本区间。

Go 使用块进行此法分区：
\begin{enumerate}[labelindent=\parindent,leftmargin=*]
\item 预声明标识符作用域为全局块。
\item 在最顶层（所有函数之外）声明的用来表示一个常量，类型，变量，或者函数（非方法）的标识符的作用域为包块。
\item 一个导入的包名的作用域为包含导入声明的文件的文件域。
\item 一个表示一个方法接收器，函数参数或结果变量的标识符的作用域为函数体。
\item 函数内声明的常量或变量标识符的作用域起始于 ConstSpec 或 Var Spec（ShortVarDecl 表示短变量声明） 结尾以及最内层包含快结尾。
\item 函数内声明的类型标识符作用域起始于 TypeSpec 中的标识符并结束于最内层包含块的结尾。
\end{enumerate}

一个区块中声明的标识符可以其内部区块重新声明。
但内部区块中声明的标识符在作用域范围内表示内部声明所声明的条目。

包子句部分并不是一个声明；包名不会出现在任何作用域内。
其目的只是为了将一些文件归纳于同一个包中，并且为导入声明指定默认的包名。

\section{标签作用域}
标签通过标签化语句声明，并用在 break，continue 和 goto 语句中。
定义一个从未用过的标签是非法的。
和其他标识符相反，标签无区块作用域并且不会和非标签的标识符冲突。
标签的作用域为声明所在的函数体内，并且不包含任何嵌套的函数体。

\section{空白标识符}
空白标识符通过下划线字符 \_ 表示。
空白标识符用作匿名占位符并在声明、操作数和赋值中具有特殊意义，

\section{预声明标识符}
下面标识符隐式的声明在全局区块中：
\begin{description}[style=nextline,leftmargin=3\parindent]
\item[Types:] 	
	{\ttfamily bool byte complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string	uint uint8 uint16 uint32 uint64 uintptr}
\item[Constants:] 
	{\ttfamily true false iota}
\item[Zero value:] 
	{\ttfamily nil}
\item[Functions:] 
	{\ttfamily append cap close complex copy delete imag len make new panic print println real recover}
\end{description}


\section{导出的标识符}
一个标识符可以被导出，从而允许在其他包里访问。
满足以下条件的标识符会被导出：
\begin{enumerate}
\item 标识符名的首字符为大写的 Unicode 字母（Unicode 类别为 ``Lu''）；并且
\item 标识符声明在包区块中或者是一个字段名或是一个方法名。
\end{enumerate}
所有其他标识符不会导出。

\section{标识符的唯一性}
在给定的标识符集合中，如果一个标识符不同于集合中任何其他标识符，则称之为唯一。
两个标识符的不同点在于拼写，或出现在不同的包中并且没有被导出。其他情况下，认为标识符相同。

\section{常量声明}
一个常量声明将一组标识符（常量的名字）绑定到一组常量表达式的值。
标识符的数量必须和表达式的数量相等，并且左边第 n 个标识符被绑定到右边第 n 个表达式的值。
\begin{lstlisting}[style=EBNF]
ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .

IdentifierList = identifier { "," identifier } .
ExpressionList = Expression { "," Expression } .
\end{lstlisting}
如果出现类型，则所有常量会采用指定的类型，并且表达式必须能够赋值给该类型。
如果省略类型，常量则会采用相应表达式的类型。
如果表达式的值为无类型常量，声明的常量依旧保留无类型，并且该常量标识符表示该常量值。
比如，若表达式是一个浮点字面量，常量标识符则会表示一个浮点常量，即便字面量的小数部分是 0。
\begin{lstlisting}[style=golang]
const Pi float64 = 3.14159265358979323846
const zero = 0.0        // untyped floating-point constant
const (
	size int64 = 1024
	eof        = -1  	// untyped integer constant
)
/* a = 3, b = 4, c = "foo", untyped integer and string constants */
const a, b, c = 3, 4, "foo"  
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
\end{lstlisting}
在使用原括弧包含的 \lstinline|const| 声明列表中，除了第一个 ConstSpec 其余的表达式列表均可以省略。
这种空列表等价于前面第一个非空表达式列表和其类型（如果有的话）的文本替换。
故，省略表达式列表等于重复前一个列表。
标识符的数量必须等于前一个列表中表达式的数量。
连同 iota 常提供量产生器一起可以提供轻量级的序列值声明：
\begin{lstlisting}[style=golang]
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Partyday
	numberOfDays  // this constant is not exported
)
\end{lstlisting}

\section{Iota}
在常量声明中，预声明标识符 \lstinline|iota| 表示连续无类型常量。
\lstinline|iota| 的值为常量声明中相应的 ConstSpec 的索引（从零开始）。
可以用来构造一组相关的常量：
\begin{lstlisting}[style=golang]
const (
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const (
	a = 1 << iota  // a == 1  (iota == 0)
	b = 1 << iota  // b == 2  (iota == 1)
	c = 3          // c == 3  (iota == 2, unused)
	d = 1 << iota  // d == 8  (iota == 3)
)

const (
	u         = iota * 42  // u == 0     (untyped integer constant)
	v float64 = iota * 42  // v == 42.0  (float64 constant)
	w         = iota * 42  // w == 84    (untyped integer constant)
)

const x = iota  // x == 0
const y = iota  // y == 0
\end{lstlisting}

根据定义，在同一个 ConstSpec 中的多个 \lstinline|iota| 具有相同的值：
\begin{lstlisting}[style=golang]
const (
	bit0, mask0 = 1 << iota, 1<<iota - 1  // bit0 == 1, mask0 == 0  (iota == 0)
	bit1, mask1                           // bit1 == 2, mask1 == 1  (iota == 1)
	_, _                                  //                        (iota == 2, unused)
	bit3, mask3                           // bit3 == 8, mask3 == 7  (iota == 3)
)
\end{lstlisting}
最后一个示例中利用了隐式的重复最后一个非空表达式列表。


\section{类型声明}
一个类型声明将一个标识符即类型名绑定到一个类型。
类型声明具有两种形式：别名声明和类型定义。
\begin{lstlisting}[style=golang]
TypeDecl = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
TypeSpec = AliasDecl | TypeDef .
\end{lstlisting}

\subsection{别名声明}
一个别名声明将一个标识符绑定到一个给定的类型上。
\begin{lstlisting}[style=EBNF]
AliasDecl = identifier "=" Type .
\end{lstlisting}
在该标识符的作用域内，提供类型别名的服务。
\begin{lstlisting}[style=golang]
type (
	nodeList = []*Node  // nodeList and []*Node are identical types
	Polar    = polar    // Polar and polar denote identical types
)
\end{lstlisting}






