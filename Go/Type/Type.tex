% !TeX root = ../Main.tex
% !TeX encoding = UTF-8
% 本文档将用于阐述 Golang 关于类型的各项细节
%
\chapter{类型}

\section{rune 字面值} 
\label{rune-literal}
有点类似与 C 中的 char 型的 Unicode 版。同样是表示一个字符 C 中的 char 型只能表示 ASCII 范围的字符，而 Go 中的 rune 字面值可以表示 Unicode 中的字符，当然也可以支持转义字符了。

\section{常量}
数值常量必须要能够表示任意精度的实际数值，并且不能溢出。所以常量无法直视 IEEE-754 负零、无穷和非数值。
常量既可以是 typed 也可以是 untyped。事实上无类型常量具有默认类型，该类型由隐式转换时上下文所需的类型决定。
\subsection{常量约束}
数值常量具体精度由编译器决定，但 Go spec 对编译器做出了最低约束：
\begin{itemize}
	\item 至少能表示 256 bit 的整型常量。
	\item 浮点常量（包括复数常量），尾数部分至少 256 bit，有符二进制指数部分至少 16 bit。
	\item 如果无法准确的表示一个整型常量应当给出错误信息。
	\item 如果应为溢出而无法表示一个浮点或者复数常量，也应当给出错误信息。
	\item 如果无法在限定的精度范围内表示一个浮点或复数常量，应当取最接近原始值的可表示的近似值。
\end{itemize}

\section{变量}
一个变量占用一定的存储位置用来保存一个值。变量所允许的值有其变量类型来决定。
结构化变量中的元素如果可独立寻址，则亦可作为变量来看待。
变量声明会为命名变量申请存储空间。
使用 \verb|new| 或者使用符合字面值的地址会在运行时为一个变量申请存储空间，这种匿名变量可以通过间接指针来访问。

\section{类型}
类型决定了值和可以施加到该值上的操作和方法。复合类型 --- array, struct, pointer, function, interface, slice, map, channel。
每一个类型 T 都具有一个底层类型\footnote{布尔，数值，字符串，类型字面值}，底层的类型的底层类型是其本身。使用关键字 \verb|type| 可以进行类型声明。
\begin{lstlisting}[language=golang, frame=single]
type {
A1 = string
A2 = A1
}
\end{lstlisting}
连个类型如果其底层类型字面结构相同则认为这两个类型相等。
\subsection{方法集}
类型可能会有与其相关联的方法集。一个接口类型的方法集合是其接口。
\subsection{字符串}
字符串类型的值是一个字节序列（该序列可能为空）。字符串类型是不可修改的。一旦创建后便无法在原有基础上修改内容。
\subsection{切片}
和数组类似，切片(slice)可索引，并且拥有一个长度。和数组不同的是，slice 类型可以在运行时更改。
slice 初始化后回合一个底层的数组相关联，该数组用来保存 slice 的元素。因此 slice 会和相同数组的其他 slice 共享存储。可以通过内置函数 \lstinline|make| 初始化一个给定类型的 slice。关于 Go 中的 slice 可以参照 python 中的概念。
\begin{lstlisting}[language=golang, frame=lb]
make([]T, length, capacity)
\end{lstlisting}

\subsection{指针类型}
指针类型表示所有指向给定类型变量的指针集合，该类型叫做指针的基类型。未被初始化的指针的值为 \verb|nil|。

\subsection{接口}
A variable of interface type can store a value of any type with a method set that is any superset of the interface.\\
一个接口类型变量可以存储任何类型为接口方法集超集的值。
这种类型被称为实现一个接口\footnote{规范里面说的很拗口，实际上和其他语言的接口类似---要实现一个接口必须实现该接口的全部方法，同时可以添加自己的方法}。未初始化的接口类型变量的值为 \lstinline|nil|。使用 \lstinline|type| 来定义一个名为  \verb|Locker| 的接口：
\begin{lstlisting}[language=golang, frame=single]
type Locker interface {
Lock()
Unlock()
}
\end{lstlisting}

所有的类型都会实现一个空接口： \lstinline|interface{}|。
接口可以嵌入\footnote{类似于 C 的面向对象设计，但要注意无法嵌套父}，即可定义如下接口类型：
\begin{lstlisting}[frame=single]
type File interface {
Read(b Buffer) bool
Write(b Buffer) bool
Locker	// 上文定义的 Locker 接口
Close()
}
\end{lstlisting}

\subsection{Map 类型}
Map 由一组单类型元素组成的无序集合，可以通过另一种类型的独一无二的 key 来索引。
可以看出 Map 类型由两种类型复合而成---元素类型和索引类型。未初始化的 map 的值为 \lstinline|nil|。Map 的 EBNF 定义如下：
\begin{verbatim}
MapType	= "map" "[" KeyType "]" ElementType .
KeyType	= Type .
\end{verbatim}
示例：
\begin{lstlisting}
map[string]int
\end{lstlisting}
通过内置函数 \lstinline|make| 创建空 map，示例：
\begin{lstlisting}
string
make(map[string]int, 100) // 100 为 map 的容量
\end{lstlisting}
\lstinline|nil map| 和空 map 类似，但是无法向其中添加元素。Map 的初始容量并不和其大小绑定，map 会根据存储的元素数量来自动扩充。

\subsection{Channel 类型}
Channel 类型通过发送和接受特定元素类型的值为并发执行函数提供通信机制。具体使用方法见官方 spec\footnote{手酸，懒得解释}，重点在于定义时可确定方向（发送方和接受方）。
