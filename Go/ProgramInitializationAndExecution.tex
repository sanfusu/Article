% !TeX root = Main.tex
\chapter{程序初始化和执行}

\section{0 值}
当为一个变量申请存储空间是，不管是通过声明还是 \code|new| 调用，亦或是，当创建新值时，使用的时复合字面量或者 \code|make| 调用，如果没有提供显式的初始化，变量或值会给予一个默认值。
每一个这种变量或值的元素会被设为其类型的零值：\code|false| 用于布尔型，\code|0| 用于数值类型，\code|""| 则为字符类型，最后 \code|nil| 用于指针、函数、接口、切片、通道和映射类型。
初始化操作会递归进行，因此对于一个结构体数组中的每一个元素在不提供初始值的情况下都会有零填充的字段。

下面两个简单声明是等价的：
\begin{golang}
var i int
var i int = 0
\end{golang}
然后
\begin{golang}
type T struct { i int; f float64; next *T }
t := new(T)
\end{golang}
具有下面的效果：
\begin{golang}
t.i == 0
t.f == 0.0
t.next == nil
\end{golang}
下面的声明也如此
\begin{golang}
var t T
\end{golang}

\section{包的初始化}
在一个包中，包级别的变量会按照声明的顺序初始化，但必须在他们所依赖的任何变量初始化完成后。

更准确的来讲，如果一个包级别的变量没有初始化变量或者其初始化变量没有依赖于未初始化的变量，可以被认为是可即将初始化的（ready for initialization)。
通过不断重复的初始化下一个最早位于声明序列且已准备好初始化的包级变量来进行包初始化，直到再也没有准备好初始化的变量。

如果当该过程结束时仍有变量未初始化，这些变量可能是一个或多个初始化循环中的一部分，并且程序无效。

在多个文件中的变量声明的顺序由展示给编译的文件顺序决定：声明在第一个文件中的变量在声明于第二个文件中的变量之前，等等。

依赖分析不会依靠变量的实际值，只取决于在源中的词法引用，并传递性的分析。
比如，如果变量 x 的初始表达式涉及到一个函数体中使用了变量 y 的函数，然后 x 依赖于 y。
特别的是：
\begin{itemize}
\item 对一个变量或函数的引用表示该变量或函数。
\item 对方法 \code|m| 的引用是一个形如 \code|t.m| 的方法值或方法表达式，其中 \code|t| 的静态类型不为接口类型，且方法 \code|m| 存在于 \code|t| 的方法集中。并不关心结果函数值 \code|t.m| 是否被调用。
\item 如果一个变量、函数或方法 \code|x| 的初始表达式或函数体（针对函数和方法）包含对变量 \code|y| 的引用或者包含一个依赖于 \code|y| 的函数或方法的引用，则 \code|x| 依赖于 \code|y|。
\end{itemize}
依赖分析会在每一个包中进行；
只考虑对当前包中声明的变量、函数和方法。

比如， 给出下列声明
\begin{golang}
var (
	a = c + b
	b = f()
	c = f()
	d = 3
)

func f() int {
	d++
	return d
}
\end{golang}
初始化顺序为 \code|d, b, c, a|。

变量可以使用声明在包块中名为 \code|init| 的函数初始化，无需参数和结果参数。
\begin{golang}
func init() { … }
\end{golang}

每个包中，甚至单个源文件中都可以定义多个这种函数。
在包块中，\code|init| 标识符只能用来声明 \code|init| 函数，然而标识符本身并没有被声明。因此 \code|init| 函数无法在程序的其他地方被使用。

一个无导入的包通过对包级别变量赋予初始值，以及后面跟着按源文件中出现的顺序（如果有多个文件，则按照展示给编译器的文件顺序）进行调用的 \code|init| 函数。
如果包具有被导入的包，则会在初始化包自身前，先初始化被导入的包。
如果多个包导入一个包，则被导入的包只会初始化一次。
包的导入，通过这种方法来保证没有循环初始化依赖。

包初始化 -- 变量初始化和 \code|init| 函数调用 -- 一次一个包的连续的发生在单个 goroutine 中。
一个 \code|init| 函数可能会发生于其他 goroutine 中，可以和初始化代码并发执行。
但是，初始化永远会序列化 \code|init| 函数：直到前一个返回之前是不会调用下一个的。

为了确保初始化行为的可重复性，build 系统建议将归属于同一个包的多个文件按照文件名字典顺序展示给编译器。

\section{程序执行}
一个完整的程序通过连接一个单一的，未导入的名为 main 的包和所有它导入的包，并以此传递来创建。
主包的名字必须为 main，并且必须声明一个无参且无返回值的 \code|main| 函数。
\begin{golang}
func main() { … }
\end{golang}
程序通过初始化主包，然后调用 \code|main| 函数来开始执行。
当函数 \code|main| 函数调用返回时，程序退出。不会等待其他非主 goroutines 的完成。
































